[toc]
# JAVA 内存模型（JMM）
## 什么是计算机内存模型
不少JAVA开发者在百度百科上没有发现计算机内存模型的概念，因为计算机内存模型是一个硬件有关的名词，但是计算机内存模型主要想表达的是计算机内存模型解决了缓存一致性问题，所以通常我们把计算机内存模型与解决缓存一致性模型来相关联。
## 为什么要有内存模型
### 内存技术的发展没有跟上CPU技术的发展
- 随着CPU技术的发展，CPU的执行速度越来越快，但是内存读取的速度还是没有太大改变。这就导致从内存中读取数据的速度会大大落后于CPU的处理速度。在性能优化方面要尽量减少IO操作就是因为这个原因。
### 缓存一致性问题
- 由于内存的读写速度与CPU的计算水平差距过大，因此在内存与CPU之间增加了缓存技术，缓存读取数据的速度快，内存小，并且非常昂贵。
- 缓存的概念就是保存了一份从内存中拷贝的数据，当运算时，数据会从主存中复制一份数据到高速缓存中，CPU就可以不访问主存，从而访问速度较快的缓存中获取数据，在速算结束后，缓存中的数据刷新到主存中。
- 由于CPU计算的能力发展过快，仅仅一级缓存不能够满足强大的计算能力，因此二级缓存，甚至三级缓存就出现了，其中从一级缓存到三级缓存的技术难度和制造成本是递减的，所以能力越大的缓存容量也最小。
- 下图为单CPU双核处理能力的缓存结构
<img src="http://www.hollischuang.com/wp-content/uploads/2018/07/CACHE.png">
- 随着计算机能力的不断提升，多核CPU多线程的出现所导致的缓存一致性问题

| 单核CPU单线程 | 单核CPU多线程 | 多核CPU多线程 |
|---|---|---|
|缓存只被一个线程访问，不会出现缓存一致性问题| 不同线程在访问相同的数据时，都会映射到相同的缓存位置，这样线程切换不会存在访问冲突 | 在多核CPU情况中每个核心都有自己的缓存，会出现缓存不一致的情况 |
### 处理器优化和指令重排问题
- 上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。
- 除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。
- 可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。
### 并发编程的问题
> 原子性
- 在一个操作中CPU不可以中途暂停然后再调度，要不执行完成，要不不完成。
> 可见性
- 当多个线程访问同一变量时，当这个变量被修改其他线程能够立刻察觉到这个变量已经被修改
> 有序性
- 程序执行的顺序按照代码的顺序整型
> 缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。
## 什么是内存模型
- 为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型
- 为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。
- 内存模型解决并发问题主要采用两种方式：[限制处理器优化]()和使用[内存屏障]()（真正搞懂类似这两个知识点的底层原理才是进入大厂所需要的实力，不然一切学习都是在学习皮毛，学不会，不搞懂，BAT就别想了）。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。
## 什么是JAVA内存模型
- Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。
- Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。
- 而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。
<img src="http://www.hollischuang.com/wp-content/uploads/2018/07/JAVA.png">
- 这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。
- 所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。
## JAVA内存模型的实现
- 了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。
- 在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。
- 本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证
> 原子性
- 在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。在synchronized的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是synchronized。
- 因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。
> 可见性
- Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。
- Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。
- 除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。
> 有序性
- 在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：
- volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。
好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。
- 但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。